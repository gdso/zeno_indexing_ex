defmodule ZenoIndexingEx do
  @dialyzer [{:nowarn_function, [generate_key: 2, get_fractional_midpoint!: 3]}]

  @moduledoc """

  In a nutshell, `ZenoIndexingEx`'s primary function (see `generate_key/2`) is 
  to generate a string-based (order) key that sorts (lexicographically) in between two 
  two other keys `a` and `b`.

  # Fractional indexes with logarithmic key growth

  While there are a number of ways to generate an order key `c` that sorts in 
  in between keys `a` and `b`, this particular module is an 
  implementation of Greenspan's _fractional indexing algorithm with logarithmic key growth_, 
  which itself an improvement on 
  Evan Wallace's _fractional indexing_ approach

  ## Examples

      # iex> ZenoIndexingEx.generate_key(nil, nil)
      # {:ok, "a0"}
      #
      #
      # iex> ZenoIndexingEx.generate_key("a0", nil)
      # {:ok, "a1"}

  ## Key format

  As described earlier, `generate_key/2` accepts keys `a`, `b`, and generates key `c`;
  in other words, all keys accepted and generated by `generate_key/2` must 
  not only conform to `order_key/0`, but also, when set to a string, 
  must be composed as follows:

  "[_integer_component_][_fractional_component_]"

  """

  # @base_10_digits "0123456789"
  @base_62_digits String.graphemes(
                    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                  )
  @base_62_digits_length length(@base_62_digits)

  # The smallest integer is the following because 
  # the A indicate the integer is encoded in 26 characters long, and the integer 
  # itself is 
  @smallest_integer "A00000000000000000000000000"
  @integer_zero "a0"

  @type order_key :: String.t() | nil

  @doc """

  Generates an order key (i.e. a key that sorts lexicographically) in 
  between the keys `a` and `b`.

  """
  @spec generate_key(order_key(), order_key()) :: {:ok, order_key()} | {:error, order_key()}
  def generate_key(a, b) do
    with true <- validate_key(a),
         true <- validate_key(b),
         true <- validate_a_b_ordering(a, b) do
      key =
        cond do
          is_nil(a) and is_nil(b) ->
            @integer_zero

          # When trying to prepend, i.e. inserting 
          # before b, where b was the head of the list of ordered keys:
          is_nil(a) and b != nil ->
            {:ok, b_integer} = get_integer_component(b)
            {:ok, b_fractional} = get_fractional_component(b, b_integer)

            # If b_integer is the smallest integer, we Cannot
            # decrement `b_integer` any further, so we can only use the
            # fractional component:
            if b_integer == @smallest_integer do
              "#{b_integer}#{get_fractional_midpoint!("", b_fractional)}"
            else
              if b_integer < b do
                b_integer
              else
                {:ok, c_integer} = decrement_integer(b_integer, @base_62_digits)
                c_integer
              end
            end

          # When trying to append to the list:
          a != nil and is_nil(b) ->
            {:ok, a_integer} = get_integer_component(a)
            {:ok, a_fractional} = get_fractional_component(a, a_integer)
            {:ok, c_integer} = increment_integer(a)

            # If the incremented integer (c_integer) isn't `nil`, which 
            # should be the case until we increment into the largest integer ...
            if c_integer != nil do
              c_integer
            else
              "#{a_integer}#{get_fractional_midpoint!(a_fractional, nil)}"
            end

          a != nil and b != nil ->
            {:ok, a_integer} = get_integer_component(a)
            {:ok, a_fractional} = get_fractional_component(a, a_integer)

            {:ok, b_integer} = get_integer_component(b)
            {:ok, b_fractional} = get_fractional_component(b, b_integer)

            if a_integer == b_integer do
              "#{a_integer}#{get_fractional_midpoint!(a_fractional, b_fractional)}"
            else
              {:ok, c_integer} = increment_integer(a_integer)

              if c_integer < b do
                c_integer
              else
                "#{a_integer}#{get_fractional_midpoint!(a_fractional, nil)}"
              end
            end

          true ->
            nil
        end

      if is_binary(key) do
        {:ok, key}
      else
        {:error, :key_gen_failed,
         "Key generation failed for an unknown reason: a = #{a}, b = #{b}"}
      end
    else
      error -> error
    end
  end

  defp validate_key(nil), do: true

  defp validate_key(key) do
    with false <- is_key_too_small(key),
         {:ok, integer} <- get_integer_component(key),
         {:ok, _fractional} <- get_fractional_component(key, integer) do
      true
    else
      error -> error
    end
  end

  defp is_key_too_small(key) do
    if(key == @smallest_integer) do
      {:error, :key_is_too_small,
       "key = #{key} is equal to the smallest integer supported in key generation algorithm"}
    else
      false
    end
  end

  defp get_integer_component(key) do
    int_length_prefix = String.at(key, 0)

    case get_int_component_length(int_length_prefix) do
      {:ok, int_component_length} ->
        integer_component = key |> String.slice(0, int_component_length)
        {:ok, integer_component}

      {:error, _, _} = error ->
        error
    end
  end

  # NOTE the integer component's prefix encodes the length of the 
  # integer string component:
  # is can range be any alphabetical value 
  # within the following ranges: A-Z, a-z. An `A` prefix indicates that 
  # the integer string will be 26 digits long, for example, see @smallest_integer.
  # And as you 
  # A 'Z' prefix indicates the integer string will 
  #
  # For example,
  #     X000 ... X999
  #     00 ... Y99
  #     0 ... Z9
  #     0 ... a9
  #     00 ... b99
  #     000 ... c999
  #     ..
  defp get_int_component_length(prefix = <<prefix_codepoint::utf8>> = _integer_length_prefix) do
    length =
      cond do
        # prefix is a character in the range between a-z:
        prefix >= "a" and prefix <= "z" ->
          # equivalent to ?a
          <<a_codepoint::utf8>> = "a"
          # NOTE we're adding 2 because, the prefix is 1 character, 
          # and the each prefix letter describes how many digits will follow:
          prefix_codepoint - a_codepoint + 2

        # prefix is a character in the range between A-Z:
        prefix >= "A" && prefix <= "Z" ->
          # equivalent to ?Z
          <<capital_z_codepoint::utf8>> = "Z"
          capital_z_codepoint - prefix_codepoint + 2

        true ->
          nil
      end

    if(length != nil,
      do: {:ok, length},
      else: {:error, :invalid_int_prefix, "Key has an invalid integer length prefix: #{prefix}"}
    )

    # if (head >= "a" && head <= "z") {
    #   return head.charCodeAt(0) - "a".charCodeAt(0) + 2;
    # } else if (head >= "A" && head <= "Z") {
    #   return "Z".charCodeAt(0) - head.charCodeAt(0) + 2;
    # } else {
    #   throw new Error("Invalid order key head: " + head);
    # }
  end

  defp get_fractional_component(key, integer_component) do
    integer_component_length = String.length(integer_component)
    fractional_component = String.slice(key, integer_component_length..-1)

    if String.slice(fractional_component, -1..-1) == "0" do
      error_message = ~s(key = #{key} has a trailing "0", i.e. an invalid fractional component)
      {:error, :invalid_fractional_component, error_message}
    else
      {:ok, fractional_component}
    end
  end

  defp validate_a_b_ordering(a, b) do
    if a != nil && b != nil && a >= b do
      {:error, :a_b_ordering_error,
       "a = #{a} must precede b = #{b} to generate key in between a and b"}
    else
      true
    end
  end

  def has_trailing_zeroes?(nil), do: false

  def has_trailing_zeroes?(key) when is_binary(key) do
    String.slice(key, -1..-1) == "0"
  end

  @spec get_fractional_midpoint!(a :: binary(), b :: binary() | nil, [String.t()]) ::
          c :: String.t()
  defp get_fractional_midpoint!(a, b, digits \\ @base_62_digits) do
    # If a lexicographically follows b, we should raise an error:
    if validate_a_b_ordering(a, b) != true do
      raise "Failed to find midpoint when a >= b, a = #{a}, b = #{b})"
    end

    if has_trailing_zeroes?(a) or has_trailing_zeroes?(b) do
      raise "Failed to find midpoint because of trailing zeroes in either a = #{a} or b = #{b}"
    end

    if (common_prefix_end = find_common_prefix(a, b)) != nil do
      common_prefix = String.slice(b, 0..common_prefix_end)
      delta_a = String.slice(a, (common_prefix_end + 1)..-1)
      delta_b = String.slice(b, (common_prefix_end + 1)..-1)
      delta_midpoint = get_fractional_midpoint!(delta_a, delta_b, digits)
      c = "#{common_prefix}#{delta_midpoint}"
      c
    else
      # NOTE reaching this `else` condition implies that 
      # there is no common prefix in `a` and `b`, i.e. 
      # a and b have the very least, different leading digits in their 
      # fractional compoment. Also, keep in mind that
      # `get_fractional_midpoint!` is called recursively, so whilst `a` 
      # `b` might initially have a common prefix, all recursive calls will eventually
      # reach this base case.

      # const digitA = a ? digits.indexOf(a.charAt(0)) : 0;
      # const digitB = b !== null ? digits.indexOf(b.charAt(0)) : digits.length;
      a_leading_digit_index =
        if is_binary(a) and a != "" do
          a_leading_digit = String.at(a, 0)
          Enum.find_index(digits, &(&1 == a_leading_digit))
        else
          0
        end

      b_leading_digit_index =
        if is_binary(b) do
          b_leading_digit = String.at(b, 0)
          Enum.find_index(digits, &(&1 == b_leading_digit))
        else
          length(digits)
        end

      leading_digits_consecutive? = b_leading_digit_index - a_leading_digit_index == 1

      if leading_digits_consecutive? do
        if b != nil and String.length(b) > 1 do
          # In this case, a and b are consecutive, but
          # b is comprised of 2 or more digits, hence, for c to sort before b,
          # all that's required is is for c to be equal to the first digit of b,
          # e.g. a = "35", b = "41", then c = "4" can satisfy a < b < c:
          c = String.first(b)
          c
        else
          # b is either null or is a single digit, in which case we can
          a_head = Enum.at(digits, a_leading_digit_index)
          a_tail = String.slice(a, 1..-1)
          midpoint_a_tail_z = get_fractional_midpoint!(a_tail, nil, digits)
          c = "#{a_head}#{midpoint_a_tail_z}"
          c
        end
      else
        # In this condition, the leading digits are not consecutive, so we can
        # find the digit that's midway:
        midway_digit_index = round(0.5 * (a_leading_digit_index + b_leading_digit_index))
        midway_digit = Enum.at(digits, midway_digit_index)
        c = midway_digit
        c
      end
    end
  end

  defp find_common_prefix(_a, nil), do: nil

  defp find_common_prefix(a, b) do
    # a = if is_nil(a), do: "", else: a

    common_prefix_end =
      Enum.reduce_while(0..String.length(b), _common_prefix_end = nil, fn i, common_prefix_end ->
        # NOTE, the length of `a` might be shorter than `b`, so we as iterate 
        # through b and compare it's characters, we can pad `a` with "0" as needed;
        # for example, if we were finding the common prefix between a = "1234" and b = "1234004",
        # the following would padd  `a` as follows "123400", to find the common
        # prefix of "123400":
        if (String.at(a, i) || "0") == String.at(b, i) do
          {:cont, i}
        else
          {:halt, common_prefix_end}
        end
      end)

    common_prefix_end
  end

  defp decrement_integer(int_component, digits) when is_binary(int_component) do
    with true <- validate_integer_component(int_component),
         int_length_prefix <- String.at(int_component, 0),
         int_string <- String.slice(int_component, 1..-1) do
      decrement_integer(int_length_prefix, int_string, digits)
    else
      error ->
        error
    end
  end

  @spec decrement_integer(
          int_length_prefix :: String.t(),
          int_string :: String.t(),
          digits :: [String.t()]
        ) ::
          {:ok, new_integer_component :: String.t()}
  defp decrement_integer(int_length_prefix, int_string, digits) do
    {
      # `subtraction_difference` is the result of subtracting 1, from right to left, from
      # `int_string`:
      subtraction_difference,
      # `most_sig_digit_overflowed`, a boolean, indicates that 
      # (1) the right to left subtraction of 1 from the less significant digits required 
      # borrowing from the most significant digit (MSD),
      # AND (2) that the MSD was 0 (the smallest digit possible)  
      # causing the MSD to overflow to the largest digit in the @base_62_digits,
      # as a result, the MSD may or may not need to be included in the final string,
      # and hence that the integer's length and prefix will need to be updated 
      # in concert (see :
      most_sig_digit_overflowed
    } =
      (_subtract_right_to_left = fn ->
         Enum.reduce_while(
           _range = (String.length(int_string) - 1)..0,
           _accumulator = {_integer_chars = String.graphemes(int_string), false},
           _reducer = fn i, {integer_chars, _} ->
             digit = Enum.at(integer_chars, i)
             i_digit = Enum.find_index(digits, &(&1 == digit))
             i_decremented_digit = i_digit - 1

             if i_decremented_digit == -1 do
               decremented_char = List.last(digits)
               integer_chars = List.replace_at(integer_chars, i, decremented_char)
               {:cont, {integer_chars, _most_sig_digit_overflowed = i == 0}}
             else
               decremented_char = Enum.at(digits, i_decremented_digit)
               integer_chars = List.replace_at(integer_chars, i, decremented_char)
               {:halt, {integer_chars, _most_sig_digit_overflowed = false}}
             end
           end
         )
       end).()

    decremented_int_length_prefix =
      if not most_sig_digit_overflowed do
        int_length_prefix
      else
        case int_length_prefix do
          "A" ->
            nil

          "a" ->
            "Z"

          <<int_length_prefix_codepoint::utf8>> ->
            <<int_length_prefix_codepoint - 1::utf8>>
        end
      end

    decremented_int_string =
      (_ensure_integer_length_matches_prefix = fn ->
         if not most_sig_digit_overflowed do
           List.to_string(subtraction_difference)
         else
           cond do
             decremented_int_length_prefix == nil ->
               nil

             decremented_int_length_prefix == "Z" ->
               List.last(@base_62_digits)

             # If the decremented integer's prefix is now in the range A-Z, 
             # the length of the integer will increase so we must 
             # add another digit:
             decremented_int_length_prefix < "Z" ->
               [subtraction_difference | List.last(@base_62_digits)]

             # decremented_int_length_prefix > "Z", so we're decrementing from say 
             # b01 - 1 = a9
             true ->
               List.delete_at(subtraction_difference, -1)
           end
         end
       end).()

    # "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    # new_integer_string =
    #   if most_sig_digit_overflowed do
    #     # new_integer_string 
    #     @smallest_integer
    #   end
    #
    # {:ok, new_integer_string}
    {:ok,
     if(decremented_int_length_prefix != nil and decremented_int_string != nil,
       do: "#{decremented_int_length_prefix}#{decremented_int_string}",
       else: nil
     )}

    # if 
    #   is_nil(decremented_int_length_prefix) or is_nil(decremented_int_string), 
    #   do: nil, 
    #   else: "#{decremented_int_length_prefix}#{decremented_int_string}"
    # }
  end

  defp validate_integer_component(integer) do
    case get_int_component_length(String.first(integer)) do
      {:ok, int_component_length} ->
        String.length(integer) == int_component_length

      _ ->
        {:error, :invalid_integer_component, "Invalid integer component #{integer}"}
    end
  end

  defp increment_integer(int_component) when is_binary(int_component) do
    with true <- validate_integer_component(int_component),
         int_length_prefix <- String.at(int_component, 0),
         int_string <- String.slice(int_component, 1..-1) do
      increment_integer(int_length_prefix, int_string)
    else
      error ->
        error
    end
  end

  defp increment_integer(int_length_prefix, int_string) do
    {
      # `subtraction_difference` is the result of subtracting 1, from right to left, from
      # `int_string`:
      sum,
      # `most_sig_digit_overflowed`, a boolean, indicates that 
      # (1) the right to left subtraction of 1 from the less significant digits required 
      # borrowing from the most significant digit (MSD),
      # AND (2) that the MSD was 0 (the smallest digit possible)  
      # causing the MSD to overflow to the largest digit in the @base_62_digits,
      # as a result, the MSD may or may not need to be included in the final string,
      # and hence that the integer's length and prefix will need to be updated 
      # in concert (see :
      most_sig_digit_overflowed
    } =
      (_add_one_to_int_string = fn ->
         Enum.reduce_while(
           _range = (String.length(int_string) - 1)..0,
           _accumulator = {_integer_chars = String.graphemes(int_string), false},
           _reducer = fn i, {integer_chars, _} ->
             digit = Enum.at(integer_chars, i)
             i_digit = Enum.find_index(@base_62_digits, &(&1 == digit))
             i_incremented_digit = i_digit + 1

             if i_incremented_digit == @base_62_digits_length do
               incremented_char = List.first(@base_62_digits)
               integer_chars = List.replace_at(integer_chars, i, incremented_char)
               {:cont, {integer_chars, _most_sig_digit_overflowed = i == 0}}
             else
               incremented_char = Enum.at(@base_62_digits, i_incremented_digit)
               integer_chars = List.replace_at(integer_chars, i, incremented_char)
               {:halt, {integer_chars, _most_sig_digit_overflowed = false}}
             end
           end
         )
       end).()

    incremented_int_length_prefix =
      if not most_sig_digit_overflowed do
        int_length_prefix
      else
        case int_length_prefix do
          "z" ->
            nil

          "Z" ->
            "a"

          # If int_length_prefix ∈ [a, z), [A, Z) 
          <<int_length_prefix_codepoint::utf8>> ->
            <<int_length_prefix_codepoint + 1::utf8>>
        end
      end

    incremented_int_string =
      (_ensure_integer_length_matches_prefix = fn ->
         if not most_sig_digit_overflowed do
           List.to_string(sum)
         else
           cond do
             incremented_int_length_prefix == nil ->
               nil

             incremented_int_length_prefix == "a" ->
               List.first(@base_62_digits)

             # If the incremented integer's prefix is now in the range A-Z, 
             # the length of the integer will increase so we must 
             # add another digit:
             incremented_int_length_prefix > "a" ->
               [sum | List.first(@base_62_digits)]

             # incremented_int_length_prefix  <= "Z", so we're reducing
             # the integer length, e.g. if we increment "bZZ" we get "a0":
             true ->
               List.delete_at(sum, -1)
           end
         end
       end).()

    {:ok,
     if(incremented_int_length_prefix != nil and incremented_int_string != nil,
       do: "#{incremented_int_length_prefix}#{incremented_int_string}",
       else: nil
     )}
  end
end
